type CognitoMFAOption {
  DeliveryMedium: String
  AttributeName: String
}

type CognitoUser {
  Username: String!
  UserAttributes: [CognitoUserAttribute]
  UserCreateDate: String
  UserLastModifiedDate: String
  Enabled: Boolean
  UserStatus: CognitoUserStatus
  MFAOptions: [CognitoMFAOption]
  PreferredMfaSetting: String
  UserMFASettingList: String
}

type CognitoUserAttribute {
  Name: String!
  Value: String
}

enum CognitoUserStatus {
  UNCONFIRMED
  CONFIRMED
  ARCHIVED
  COMPROMISED
  UNKNOWN
  RESET_REQUIRED
  FORCE_CHANGE_PASSWORD
}

input CreateCustomerAccountInput {
  customerUsername: ID!
}

input CreateStudentAccountInput {
  givenName: String!
  familyName: String!
  birthdate: AWSDate!
  email: AWSEmail!
}

input CreateTeacherAccountInput {
  givenName: String!
  familyName: String!
  email: AWSEmail!
  phone: AWSPhone!
}

type CustomerAccount
  @auth(rules: [{ allow: private, provider: iam }])
  @key(
    name: "ByCustomerUsername"
    fields: ["customerUsername"]
    queryField: "customerAccountsByCustomerUsername"
  )
  @model(mutations: null, subscriptions: null) {
  id: ID!
  customerUsername: ID!
  stripeCustomerId: ID!
}

input DeleteCustomerAccountInput {
  id: ID!
}

input DeleteStudentAccountInput {
  id: ID
}

input DeleteTeacherAccountInput {
  id: ID
}

# TODO: create lesson
# TODO: mirror booking
# TODO: attach lessons to students
# TODO: create StudentEvent type

input ModelCustomerAccountConditionInput {
  and: [ModelCustomerAccountConditionInput]
  or: [ModelCustomerAccountConditionInput]
  not: ModelCustomerAccountConditionInput
}

input ModelStudentAccountConditionInput {
  and: [ModelStudentAccountConditionInput]
  or: [ModelStudentAccountConditionInput]
  not: ModelStudentAccountConditionInput
}

input ModelTeacherAccountConditionInput {
  and: [ModelTeacherAccountConditionInput]
  or: [ModelTeacherAccountConditionInput]
  not: ModelTeacherAccountConditionInput
}

type Mutation {
  createCustomerAccount(
    input: CreateCustomerAccountInput!
    condition: ModelCustomerAccountConditionInput
  ): CustomerAccount @aws_iam

  createStudentAccount(
    input: CreateStudentAccountInput!
    condition: ModelStudentAccountConditionInput
  ): StudentAccount

  createTeacherAccount(
    input: CreateTeacherAccountInput!
    condition: ModelTeacherAccountConditionInput
  ): TeacherAccount

  deleteCustomerAccount(
    input: DeleteCustomerAccountInput!
    condition: ModelCustomerAccountConditionInput
  ): CustomerAccount @aws_iam

  deleteStudentAccount(
    input: DeleteStudentAccountInput!
    condition: ModelStudentAccountConditionInput
  ): StudentAccount

  deleteTeacherAccount(
    input: DeleteTeacherAccountInput!
    condition: ModelTeacherAccountConditionInput
  ): TeacherAccount

  updateStudentAccount(input: UpdateStudentAccountInput!): StudentAccount
    @aws_iam
}

type Resource
  @auth(
    rules: [
      { allow: private, provider: iam }
      { allow: groups, groups: ["Admins"] }
      { allow: groups, groups: ["Teachers"], operations: [create, update] }
      { allow: private, operations: [read] }
    ]
  )
  @model
  @searchable
  @versioned {
  id: ID!
  name: String!
  description: String
  url: AWSURL
  resourceTopics: [ResourceTopic!]!
    @connection(keyName: "ByResourceId", fields: ["id"])
}

type ResourceTopic
  @auth(
    rules: [
      { allow: private, provider: iam }
      { allow: groups, groups: ["Admins"] }
      { allow: groups, groups: ["Teachers"], operations: [create, delete] }
      { allow: private, operations: [read] }
    ]
  )
  @key(
    name: "ByResourceId"
    fields: ["resourceId"]
    queryField: "resourceTopicByResourceId"
  )
  @key(
    name: "ByTopicId"
    fields: ["topicId"]
    queryField: "resourceTopicByTopicId"
  )
  @model(queries: null) {
  id: ID!
  resourceId: ID!
  resource: Resource @connection(fields: ["resourceId"])
  topicId: ID!
  topic: Topic @connection(fields: ["topicId"])
}

enum StripeAggregateUsageType {
  sum
  max
}

type StripeCard {
  brand: String!
  exp_month: Int!
  exp_year: Int!
  fingerprint: String!
  funding: StripeFundingType!
  last4: String!
}

type StripeCustomer {
  id: ID!
}

enum StripeFundingType {
  credit
  debit
  prepaid
  unknown
}

enum StripeIntervalType {
  day
  week
  month
  year
}

type StripePaymentMethod {
  id: ID!
  stripeCustomerId: ID
  type: StripePaymentMethodType!
  card: StripeCard
}

enum StripePaymentMethodType {
  alipay
  au_becs_debit
  bacs_debit
  bancontact
  card
  eps
  fpx
  giropay
  ideal
  p24
  sepa_debit
  sofort
}

type StripePrice {
  id: ID!
  product: StripeProduct!
  recurring: StripeRecurringPriceAttributes
  type: StripePriceType!
  unit_amount: Int!
}

enum StripePriceType {
  one_time
  recurring
}

type StripeProduct {
  id: ID!
  description: String
  name: String!
  unit_label: String
}

type StripeRecurringPriceAttributes {
  aggregate_usage: StripeAggregateUsageType!
  interval: StripeIntervalType!
  interval_count: Int!
  usage_type: StripeUsageType!
}

type StripeSubscription {
  id: ID!
  cancel_at_period_end: Boolean!
  current_period_end: AWSTimestamp!
  current_period_start: AWSTimestamp!
  customer: ID!
  default_payment_method: ID
  items: [StripeSubscriptionItem!]!
  status: StripeSubscriptionStatus!
}

type StripeSubscriptionItem {
  id: ID!
  price: StripePrice!
  quantity: Int!
  subscription: ID!
}

enum StripeSubscriptionStatus {
  incomplete
  incomplete_expired
  trialing
  active
  past_due
  canceled
  unpaid
}

type StripeUsageRecord {
  id: ID!
  quantity: Int!
  subscription_item: ID!
  timestamp: AWSTimestamp
}

enum StripeUsageType {
  metered
  licensed
}

type StudentAccount
  @auth(
    rules: [
      { allow: groups, groups: ["Admins"] }
      { allow: groups, groups: ["Customers"], operations: [create] }
      { allow: groups, groups: ["Teachers"], operations: [read] }
      {
        allow: owner
        ownerField: "customerUsername"
        operations: [read, delete]
      }
      { allow: owner, ownerField: "studentUsername", operations: [read] }
      { allow: private, provider: iam, operations: [read, update] }
    ]
  )
  @key(
    name: "ByCustomerUsername"
    fields: ["customerUsername"]
    queryField: "studentAccountsByCustomerUsername"
  )
  @model(mutations: null, subscriptions: null) {
  id: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  customerUsername: ID!
  customerUser: CognitoUser @function(name: "resolveField-${env}")
  studentUsername: ID!
  studentUser: CognitoUser @function(name: "resolveField-${env}")
  stripeSubscriptionId: ID!
  stripeSubscription: StripeSubscription @function(name: "resolveField-${env}")
}

# TODO: update subscription inputs?
type Subscription {
  onCreateCustomerAccount(
    customerUsername: String
    customerAccountId: String
  ): CustomerAccount @aws_subscribe(mutations: ["createCustomerAccount"])

  onCreateStudentAccount(
    customerUsername: String
    studentUsername: String
  ): StudentAccount @aws_subscribe(mutations: ["createStudentAccount"])

  onCreateTeacherAccount(
    teacherUsername: String
    teacherAccountId: String
  ): TeacherAccount @aws_subscribe(mutations: ["createTeacherAccount"])

  onDeleteCustomerAccount(
    customerUsername: String
    customerAccountId: String
  ): CustomerAccount @aws_subscribe(mutations: ["deleteCustomerAccount"])

  onDeleteStudentAccount(
    customerUsername: String
    studentUsername: String
  ): StudentAccount @aws_subscribe(mutations: ["deleteStudentAccount"])

  onDeleteTeacherAccount(
    teacherUsername: String
    teacherAccountId: String
  ): TeacherAccount @aws_subscribe(mutations: ["deleteTeacherAccount"])

  onUpdateStudentAccount(
    customerUsername: String
    studentUsername: String
  ): StudentAccount @aws_subscribe(mutations: ["updateStudentAccount"])
}

type TeachableTopic
  @auth(
    rules: [
      { allow: private, provider: iam }
      { allow: groups, groups: ["Admins"] }
      { allow: private, operations: [read] }
    ]
  )
  @key(
    name: "ByTeacherAccountId"
    fields: ["teacherAccountId"]
    queryField: "teachableTopicByTeacherAccountId"
  )
  @key(
    name: "ByTopicId"
    fields: ["topicId"]
    queryField: "teachableTopicTopicByTopicId"
  )
  @model(queries: null) {
  id: ID!
  teacherAccountId: ID!
  teacherAccount: TeacherAccount @connection(fields: ["teacherAccountId"])
  topicId: ID!
  topic: Topic @connection(fields: ["topicId"])
}

# TODO: implement update mutation
# TODO: authorize iam to perform update mutation
type TeacherAccount
  @auth(
    rules: [
      { allow: groups, groups: ["Admins"] }
      { allow: private, operations: [read] }
    ]
  )
  @model(mutations: null, subscriptions: null) {
  id: ID!
  teacherUsername: ID!
  teacherUser: CognitoUser @function(name: "resolveField-${env}")
  topics: [TeachableTopic!]!
    @connection(keyName: "ByTeacherAccountId", fields: ["id"])
  # TODO: add lessons
}

type Topic
  @auth(
    rules: [
      { allow: private, provider: iam }
      { allow: groups, groups: ["Admins"] }
      { allow: private, operations: [read] }
      { allow: groups, groups: ["Teachers"], operations: [create, update] }
    ]
  )
  @model
  @searchable
  @versioned {
  id: ID!
  name: String!
  description: String
  resourceTopics: [ResourceTopic!]!
    @connection(keyName: "ByTopicId", fields: ["id"])
  teachableTopics: [TeachableTopic!]!
    @connection(keyName: "ByTopicId", fields: ["id"])
}

input UpdateStudentAccountInput {
  id: ID!
  stripeSubscriptionId: ID!
}

#type Workspace {

#}

#type WorkspaceUsageRecord {

#}
